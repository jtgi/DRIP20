// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/Extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

import "./IMirakaiOnChainMetadata.sol";

import {console} from "forge-std/console.sol";

contract MirakaiScrolls is Ownable, ERC721Burnable {
    using ECDSA for bytes32;
    using Strings for uint256;

    uint256 public constant MAX_SUPPLY = 10000;
    uint256 public constant TEAM_RESERVE = 85;
    uint256 public constant BASE_PRICE = 0.05 ether;
    uint256 public constant MAX_ELECTED_MINT_SUPPLY = 1000;
    uint256 public currElectedMintTotal;
    bool public teamHasMinted;

    // tokenID mapping to struct
    mapping(uint256 => TokenIdValues) public values;

    struct TokenIdValues {
        uint256 value1;
        uint256 value2;
        uint256 value3;
    }

    function setValues(uint256 tokenId, uint256 value) external {
        if (value == 1) {
            values[tokenId].value1 = value;
        } else if (value == 2) {
            values[tokenId].value2 = value;
        } else {
            values[tokenId].value3 = value;
        }
    }

    function basePrice() external pure returns (uint256) {
        return BASE_PRICE;
    }

    function x() external view returns (uint256) {
        return MAX_ELECTED_MINT_SUPPLY << 14;
    }

    function y() external view returns (uint256) {
        return MAX_ELECTED_MINT_SUPPLY**2;
    }

    address public onchainMetadataAddress;
    uint256 public mintprice;
    // tokenId to dna
    mapping(uint256 => uint256) public dna;
    // mapping of whether a token has a cc0 trait
    mapping(uint256 => uint256) public cc0;
    bool public mintIsActive;
    bool public cc0MintIsActive;
    bool public electedMintIsActive;

    uint256 private _totalSupply;
    // for rng
    uint256 private _seed;
    uint256 private _nonce;
    address private _signatureVerifier;
    // for fallback
    string private _tokenBaseURI;

    enum Traits {
        Clan,
        Genus,
        Head,
        Eyes,
        Mouth,
        Upper,
        Lower,
        Weapon,
        Accessory,
        Pet
    }

    uint256 private constant BIT_MASK = 2**14 - 1;

    uint256 private constant CLAN_BITSHIFT_MULTIPLE = 0;
    uint256 private constant GENUS_BITSHIFT_MULTIPLE = 1;
    uint256 private constant HEAD_BITSHIFT_MULTIPLE = 2;
    uint256 private constant EYES_BITSHIFT_MULTIPLE = 3;
    uint256 private constant MOUTH_BITSHIFT_MULTIPLE = 4;
    uint256 private constant UPPER_BITSHIFT_MULTIPLE = 5;
    uint256 private constant LOWER_BITSHIFT_MULTIPLE = 6;
    uint256 private constant WEAPON_BITSHIFT_MULTIPLE = 7;
    uint256 private constant ACCESSORY_BITSHIFT_MULTIPLE = 8;
    uint256 private constant PET_BITSHIFT_MULTIPLE = 9;

    address private CHAIN_RUNNERS_ADDRESS;
    address private BLITMAP_ADDRESS;
    address private CRYPTOADZ_ADDRESS;
    address private ANONYMICE_ADDRESS;

    uint256 private constant CHAIN_RUNNER_CC0_INDEX = 1;
    uint256 private constant BLITMAP_CC0_INDEX = 2;
    uint256 private constant CRYPTOADZ_CC0_INDEX = 3;
    uint256 private constant ANONYMICE_CC0_INDEX = 4;

    event scrollReroll(uint256 tokenId);

    constructor() ERC721("Mirakai Scrolls", "MIRIKAI_SCROLLS") {}

    uint256 private constant AB = 16;
    uint256 private constant AC = 14;

    function test(uint256 d) external returns (uint256) {
        uint256 tokenDna = uint256(
            keccak256(
                abi.encodePacked(
                    msg.sender,
                    block.difficulty,
                    block.timestamp,
                    _seed
                )
            )
        );
        uint256 a = dna[d];

        uint256 newnew = a -
            (a % 10**AB) +
            (a % 100**AC) +
            (tokenDna % 100) *
            10**AC +
            (tokenDna % 100) *
            10**AC;
        dna[d] = newnew;
        emit scrollReroll(d);
        return
            a -
            (a % 10**AB) +
            (a % 100**AC) +
            (tokenDna % 100) *
            10**AC +
            (tokenDna % 100) *
            10**AC;
    }

    function setOnchainMetadataAddress(address _onchainMetadataAddress)
        external
        onlyOwner
    {
        onchainMetadataAddress = _onchainMetadataAddress;
    }

    function flipMint() external onlyOwner {
        mintIsActive = !mintIsActive;
    }

    function flipCC0Mint() external onlyOwner {
        cc0MintIsActive = !cc0MintIsActive;
    }

    function flipElectedMint() external onlyOwner {
        electedMintIsActive = !electedMintIsActive;
    }

    function changeSeed(uint256 newSeed) external onlyOwner {
        _seed = newSeed;
    }

    function mintPublic(uint256 quantity) external payable {
        uint256 currSupply = _totalSupply;

        require(tx.origin == msg.sender, "no SC mints");
        require(mintIsActive, "mint not active");
        require(currSupply + quantity < MAX_SUPPLY, "not enough supply");
        require(quantity <= 5, "max 5 per txn");
        require(quantity * mintprice == msg.value, "incorrect ether sent");

        for (uint256 i = 0; i < quantity; i++) {
            mint(currSupply++);
        }

        _totalSupply = currSupply;
    }

    function teamMint() external onlyOwner {
        require(!teamHasMinted, "team has minted");
        uint256 currSupply = _totalSupply;

        for (uint256 i = 0; i < TEAM_RESERVE; i++) {
            mint(currSupply++);
        }

        _totalSupply = currSupply;
    }

    function setMintPrice() external onlyOwner {
        mintprice = address(this).balance / currElectedMintTotal;
    }

    function electedMint() external payable {
        uint256 currSupply = _totalSupply;

        require(tx.origin == msg.sender, "no SC mints");
        require(electedMintIsActive, "elected mint not active");
        require(currSupply + 1 < MAX_SUPPLY, "not enough supply");
        require(
            currElectedMintTotal + 1 < MAX_ELECTED_MINT_SUPPLY,
            "not enough supply"
        );
        require(BASE_PRICE <= msg.value, "not enough ether sent");

        mint(currSupply++);
        _totalSupply = currSupply;
        ++currElectedMintTotal;
    }

    // use merkle for this
    function cc0Mint(uint256 cc0Index) external payable {
        require(cc0Check(cc0Index), "cc0 not in wallet");
        uint256 currSupply = _totalSupply;

        require(tx.origin == msg.sender, "no SC mints");
        require(cc0MintIsActive, "mint not active");
        require(currSupply + 1 < MAX_SUPPLY, "not enough supply");
        require(mintprice == msg.value, "incorrect ether sent");
        uint256 tokenDna = uint256(
            keccak256(
                abi.encodePacked(
                    currSupply,
                    msg.sender,
                    block.difficulty,
                    block.timestamp,
                    _seed,
                    _nonce++
                )
            )
        );

        if ((tokenDna << (14 * 10)) % 100 < 20) {
            cc0[currSupply] = cc0Index;
        }

        dna[currSupply] = tokenDna;
        _mint(msg.sender, currSupply++);
    }

    function cc0Check(uint256 cc0Index) internal view returns (bool) {
        if (cc0Index == CHAIN_RUNNER_CC0_INDEX) {
            return IERC721(CHAIN_RUNNERS_ADDRESS).balanceOf(msg.sender) > 0;
        } else if (cc0Index == BLITMAP_CC0_INDEX) {
            return IERC721(BLITMAP_ADDRESS).balanceOf(msg.sender) > 0;
        } else if (cc0Index == CRYPTOADZ_CC0_INDEX) {
            return IERC721(CRYPTOADZ_ADDRESS).balanceOf(msg.sender) > 0;
        } else if (cc0Index == ANONYMICE_CC0_INDEX) {
            return IERC721(ANONYMICE_ADDRESS).balanceOf(msg.sender) > 0;
        }

        return false;
    }

    // traits are represented in a 256 bit int, every 14 bits is a new trait.
    // to re-roll, we'll zero out the bits for a certain trait, then shift in
    // the new bits for the new trait.
    //
    // for example, we'll use 5 bit traits
    // new eye trait == 01111
    //
    // old dna looks like:
    // 10110 00110 01000 11001 00100
    //  |     |      |
    // head  eyes  mouth  etc
    //
    // we zero our current eye trait by shifting 11111 enough times to match the eye traits
    // and then negating it, which will give us a bitmask of:
    // 00000 11111 11111 11111
    //
    // we then do a bitwise AND with our old dna, which will zero out our desired trait.
    // we then 'slide' in our new trait using the same method of shifting (new bit mask)
    // and doing an OR operation.

    function rerollTrait(uint256 tokenId, uint256 traitBitShiftMultiplier)
        external
    {
        require(ownerOf(tokenId) == msg.sender, "not owner");
        require(traitBitShiftMultiplier > 1, "clan/genus is fixed");
        uint256 currDna = dna[tokenId];

        unchecked {
            uint256 newTraitDna = (uint256(
                keccak256(
                    abi.encodePacked(
                        msg.sender,
                        block.difficulty,
                        block.timestamp,
                        _seed,
                        tokenId,
                        _nonce++
                    )
                )
            ) % 10000) << (14 * traitBitShiftMultiplier);

            uint256 newBitMask = ~(BIT_MASK << (14 * traitBitShiftMultiplier));

            currDna &= newBitMask;
            currDna |= newTraitDna;
        }

        dna[tokenId] = currDna;
        emit scrollReroll(tokenId);
    }

    function setOnchainMetadataAddess(address addr) external onlyOwner {
        onchainMetadataAddress = addr;
    }

    function getTraitsDna(uint256 tokenId)
        external
        view
        returns (uint256[9] memory)
    {
        return
            IMirakaiOnChainMetadata(onchainMetadataAddress).splitDna(
                dna[tokenId]
            );
    }

    function render(uint256 tokenId) external view returns (string memory) {
        return
            IMirakaiOnChainMetadata(onchainMetadataAddress).render(
                dna[tokenId]
            );
    }

    function tokenU(uint256 tokenId) external view returns (string memory) {
        console.log("ASD", dna[tokenId]);
        return
            IMirakaiOnChainMetadata(onchainMetadataAddress).tokenURI(
                tokenId,
                dna[tokenId]
            );
    }

    function mint(uint256 tokenId) internal {
        dna[tokenId] = uint256(
            keccak256(
                abi.encodePacked(
                    tokenId,
                    msg.sender,
                    block.difficulty,
                    block.timestamp,
                    _seed,
                    _nonce++
                )
            )
        );

        _mint(msg.sender, tokenId);
    }

    function tokenURI(uint256 _tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        // require(
        //     _exists(_tokenId),
        //     "ERC721Metadata: URI query for nonexistent token"
        // );
        // if (renderingContractAddress == address(0)) {
        //     return "";
        // }
        // IChainRunnersRenderer renderer = IChainRunnersRenderer(
        //     renderingContractAddress
        // );
        // return renderer.tokenURI(_tokenId, runners[_tokenId]);
    }

    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    }
}
